Goat Pattern
===

Goat is a Java dependency of the reactive-like developing pattern.
It provides a set of abstract tools to make it detached between systems / services.

## Project Structure

- **goat-dependencies**: Dependency management
- **goat-api**: Core interfaces and abstractions
- **goat-core**: Implementation of core components
- **goat-platform**: Platform-specific implementations

## Getting Started

- To use Goat Pattern in your project, add the following dependencies to your Maven pom.xml:
- (It's not in the maven repository. You might have to build it yourself.)

```pom
<dependency>
    <groupId>com.hiro.goat</groupId>
    <artifactId>goat-api</artifactId>
    <version>0.0.1</version>
</dependency>

<dependency>
    <groupId>com.hiro.goat</groupId>
    <artifactId>goat-core</artifactId>
    <version>0.0.1</version>
</dependency>
```

## Maven Commends

### Build Tool

1. Build dependency config (pom)

```shell

cd ./goat-dependencies
mvn clean install
```

2. Build project

```shell

mvn clean install -am -DskipTests
```

### Run Unit Tests

```shell

# run test
mvn clean test -am

# or run verify
mvn clean verify -am
```

## Core Features

### Signature

- Signable: A object contains signable data, and signature generated by Signer (String).
- Signer: Accept the signable and generate a signature.

```java
void sign(Signable signable);
```

- Verifier: Verify signature in signable.

```java
boolean verify(Signable signable);
```

---

### Worker (Lifecycle pattern)

- Lifecycle: Define a continuous system's lifecycle.
- Worker: Use lifecycle system to control work.
- Dispatcher: A worker consume <T> to dispatch <T> to executor.
- To use:

```java
public static void main(String[] args) {

    // Example:
    Set<String> words = ConcurrentHashMap.newKeySet();

    // generate with a Consumer
    DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add);

    // start working dispatcher
    dispatcher.start();

    // submit would throw on fail
    dispatcher.submit("string-1");

    // offer would return false on fail
    boolean success = dispatcher.offer("string-2");
}
```

#### Customizable options:

- Executor:

```java
// Annotation: 
@DispatchExecutor(
        // Executor base size
        coreSize = 8,
        // Executor max size
        maxSize = 32,
        // Task queue in executor
        queueCapacity = 128,
        // Recycle thread after rest for this seconds 
        keepAliveTime = 120
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

```java
// Override: Can also use virtual thread
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

    @Override
    protected ExecutorService defineExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }

}
```

```java
// Constructor: accept Supplier<ExecutorService>
DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add,
                () -> Executors.newVirtualThreadPerTaskExecutor());
```

- Task Consumer

```java
// Override: if there's extra design for dispatcher
public class Notifier extends QueueDispatcherWorker<String> {

    private final NotifyService notifyService;

    @Override
    protected void processTask(String notice) {
        notifyService.notify(notice);
    }

}
```

```java
// Constructor
Set<String> words = new HashSet<>();

DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add);
```

- Task Deque

```java
// Annotation:
@DispatchDequeue(
        // Task queue size
        size = 100,
        // Task process type before pause / stop / destroy Dispatcher
        // CONSUME: Try to consume all task (will discard all after timeout)
        // DISCARD: Discard all rest tasks directly
        // CUSTOMIZE: Process with override method customizeRestConsumer()
        schedule = ResidualTaskSchedule.CUSTOMIZE,
        // Discard all task after this time (only use CONSUME)
        timeout = 120L,
        // timeout unit (only use CONSUME) 
        timeoutUnit = TimeUnit.SECONDS
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

- Overloading alert

```java
// Annotation:
@DispatchAlert(
        // Alert while deque current loading
        alertSize = 80,
        // Only alert one time in this period
        alertPeriod = 12,
        // period tume unit
        periodUnit = TimeUnit.HOURS
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

---

### Postal System
