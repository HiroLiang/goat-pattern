Goat Pattern
===

Goat is a Java dependency of the reactive-like developing pattern.
It provides a set of abstract tools to make it detached between systems / services.

## Project Structure

- **goat-dependencies**: Dependency management
- **goat-api**: Core interfaces and abstractions
- **goat-core**: Implementation of core components
- **goat-platform**: Platform-specific implementations

## Getting Started

- To use Goat Pattern in your project, add the following dependencies to your Maven pom.xml:
- (It's not in the maven repository. You might have to build it yourself.)

```pom
<dependency>
    <groupId>com.hiro.goat</groupId>
    <artifactId>goat-api</artifactId>
    <version>0.0.1</version>
</dependency>

<dependency>
    <groupId>com.hiro.goat</groupId>
    <artifactId>goat-core</artifactId>
    <version>0.0.1</version>
</dependency>
```

## Maven Commends

### Build Tool

- Build dependency config (pom)

```shell

cd ./goat-dependencies
mvn clean install
```

- Build project

```shell

mvn clean install -am -DskipTests
```

### Run Unit Tests

```shell

# run test
mvn clean test -am

# or run verify
mvn clean verify -am
```

## Core Features

### Signature

- Signable: A object contains signable data, and signature generated by Signer (String).
- Signer: Accept the signable and generate a signature.

```java
void sign(Signable signable);
```

- Verifier: Verify signature in signable.

```java
boolean verify(Signable signable);
```

---

### Worker (Lifecycle pattern)

- Lifecycle: Define a continuous system's lifecycle.
- Worker: Use a lifecycle system to control work.
- Dispatcher: A worker consumes <T> to dispatch <T> to the executor.
- To use:

```java
public static void main(String[] args) {

    // Example:
    Set<String> words = ConcurrentHashMap.newKeySet();

    // generate with a Consumer
    DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add);

    // start working dispatcher
    dispatcher.start();

    // submit would throw on fail
    dispatcher.submit("string-1");

    // offer would return false on fail
    boolean success = dispatcher.offer("string-2");
}
```

#### Customizable options:

- Executor:

```java
// Annotation: 
@DispatchExecutor(
        // Executor base size
        coreSize = 8,
        // Executor max size
        maxSize = 32,
        // Task queue in executor
        queueCapacity = 128,
        // Recycle thread after rest for this second 
        keepAliveTime = 120
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

```java
// Override: Can also use virtual thread
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

    @Override
    protected ExecutorService defineExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }

}
```

```java
// Constructor: accept Supplier<ExecutorService>
DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add,
                () -> Executors.newVirtualThreadPerTaskExecutor());
```

- Task Consumer

```java
// Override: if there's extra design for dispatcher
public class Notifier extends QueueDispatcherWorker<String> {

    private final NotifyService notifyService;

    @Override
    protected void processTask(String notice) {
        notifyService.notify(notice);
    }

}
```

```java
// Constructor
Set<String> words = new HashSet<>();

DispatchWorker<String> dispatcher = new QueueDispatchWorker<>(words::add);
```

- Task Deque

```java
// Annotation:
@DispatchDequeue(
        // Task queue size
        size = 100,
        // Task process type before pause / stop / destroy Dispatcher
        // CONSUME: Try to consume all tasks (will discard all after timeout)
        // DISCARD: Discard all rest tasks directly
        // CUSTOMIZE: Process with override method customizeRestConsumer()
        schedule = ResidualTaskSchedule.CUSTOMIZE,
        // Discard all tasks after this time (only use CONSUME)
        timeout = 120L,
        // timeout unit (only use CONSUME) 
        timeoutUnit = TimeUnit.SECONDS
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

- Overloading alert

```java
// Annotation:
@DispatchAlert(
        // Alert while deque current loading
        alertSize = 80,
        // Only alert one time in this period
        alertPeriod = 12,
        // period time unit
        periodUnit = TimeUnit.HOURS
)
public class CustomDispatcher<T> extends QueueDispatcherWorker<T> {

}
```

---

### Postal System

- Implement of Dispatcher
- Generate mailbox for register and let mailbox can deliver postal parcel through the postal center.
- To use:

```java
// Extends PostalCenter and define what you want the parcel to carry.
public class TestPostalCenter extends PostalCenter<String> {

    // Provide a secret for Mac Signer, 
    public TestPostalCenter(String secret) {
        super(secret);
    }

    @Override
    protected long createPostalCode() {
        // Define how to generate postal code
    }

    @Override
    protected Mailbox<String> createMailBox(long postalCode) {
        // Define what kind of mailbox you want to create by the postal code
    }

}
```

```java
public class TestMailbox extends Mailbox<String> {

    // To generate mailbox at least need postal code and the HmacSha256Signer in the postal center.
    public TestMailbox(long postalCode, Verifier verifier) {
        super(postalCode, verifier);
    }

    // Define how postal center to deliver parcel to this mailbox.
    @Override
    public void deliver(PostalParcel<String> parcel) {
        this.word = parcel.verifying(this).reveal();
        log.info("TestMailBox receive parcel contains: {}", this.word);
    }

}
```

```java
public static void main(String[] args) {
    PostalCenter<String> postalCenter = new TestPostalCenter("dev-secret-123456");

    // Start running the postal center
    postalCenter.start();

    // Use register to get mailbox
    Mailbox<String> mailbox = postalCenter.register();

    // Giving a target postal code to get a parcel. 
    long targetPostalCode = 1L;
    PostalParcel<String> parcel = postalCenter.getParcel(mailbox, targetPostalCode, RecipientType.MAILBOX);

    // Use submit or offer to hang over the parcel.
    postalCenter.submit(parcel);
    postalCenter.offer(parcel);
}
```

### Platform System